<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; img-src 'self' data:; style-src 'self' 'unsafe-inline'">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>RecallOS</title>
    <style>
      :root {
        /* VS Code-inspired light theme */
        --background: #fafafa;
        --foreground: #333333;
        --card: #ffffff;
        --border: #e2e2e2;
        --muted: #f3f3f3;
        --muted-foreground: #7a7a7a;
        --primary: #007acc;
        --primary-foreground: #ffffff;
        --destructive: #c62828;
        --ring: #007acc;
        --radius: 10px;
        color-scheme: light;
      }
      @media (prefers-color-scheme: dark) {
        :root:not([data-theme="light"]) {
          /* VS Code-inspired dark */
          --background: #1e1e1e;
          --foreground: #cccccc;
          --card: #252526;
          --border: #333333;
          --muted: #2a2a2a;
          --muted-foreground: #999999;
          --primary: #007acc;
          --primary-foreground: #ffffff;
          --destructive: #c62828;
          --ring: #007acc;
          color-scheme: dark;
        }
      }
      /* Explicit overrides when user sets theme */
      :root[data-theme="light"] { color-scheme: light; }
      :root[data-theme="dark"] {
        --background: #1e1e1e;
        --foreground: #cccccc;
        --card: #252526;
        --border: #333333;
        --muted: #2a2a2a;
        --muted-foreground: #999999;
        --primary: #007acc;
        --primary-foreground: #ffffff;
        --destructive: #c62828;
        --ring: #007acc;
        color-scheme: dark;
      }
      html, body {
        height: 100%;
      }
      body {
        margin: 0;
        background: var(--background);
        color: var(--foreground);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Inter, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
        line-height: 1.45;
      }
      #app { max-width: 1100px; margin: 0 auto; padding: 16px 20px 40px; }
      .topbar { position: sticky; top: 0; z-index: 100; background: var(--background); border-bottom: 1px solid var(--border); margin: -16px -20px 16px; padding: 10px 20px; display: flex; align-items: center; justify-content: space-between; gap: 12px; }
      .brand { display: flex; align-items: center; gap: 10px; font-weight: 700; }
      .brand .dot { width: 10px; height: 10px; border-radius: 50%; background: var(--primary); display: inline-block; }
      .toolbar { display: flex; align-items: center; gap: 8px; }
      select, input[type="date"], input[type="text"], input[type="search"] { background: var(--card); color: var(--foreground); border: 1px solid var(--border); border-radius: 8px; padding: 6px 8px; outline: none; }
      button { background: var(--muted); color: var(--foreground); border: 1px solid var(--border); border-radius: 8px; padding: 6px 10px; cursor: pointer; }
      button:hover { background: var(--card); }
      button.primary { background: var(--primary); color: var(--primary-foreground); border-color: var(--primary); }
      button.primary:hover { filter: brightness(1.05); }
      hr { border: 0; border-top: 1px solid var(--border); margin: 16px 0; }
      section { background: var(--card); border: 1px solid var(--border); border-radius: var(--radius); padding: 12px; }
      h1, h3 { margin: 0 0 8px; }
      /* Cards */
      .card { border: 1px solid var(--border); border-radius: 10px; padding: 8px; background: var(--card); }
      /* REC badge */
      #rec-badge { position: fixed; top: 10px; right: 10px; background: var(--destructive) !important; color: #fff; padding: 6px 10px; border-radius: 999px; font-weight: bold; z-index: 9999; display: none; box-shadow: 0 2px 8px rgba(0,0,0,0.25); }
      /* Modals */
      #first-run, #consent { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; z-index: 9998; background: rgba(0,0,0,0.45); backdrop-filter: saturate(120%) blur(1px); }
      #first-run > div, #consent > div { background: var(--card) !important; color: var(--foreground) !important; padding: 18px; border-radius: 12px; border: 1px solid var(--border); box-shadow: 0 10px 30px rgba(0,0,0,0.3); }
      #sources { display: flex; gap: 12px; flex-wrap: wrap; }
      .source-card { width: 200px; }
      .muted { color: var(--muted-foreground); font-size: 12px; }
    </style>
  </head>
  <body>
    <div id="app">
      <div class="topbar">
        <div class="brand"><span class="dot"></span> <span>RecallOS</span></div>
        <div class="toolbar">
          <label for="theme-select" class="muted">Theme</label>
          <select id="theme-select">
            <option value="system" selected>System</option>
            <option value="light">Light</option>
            <option value="dark">Dark</option>
          </select>
          <button id="open-settings" title="Open Settings window">Settings…</button>
        </div>
      </div>
      <div id="rec-badge">REC</div>
      <div id="first-run">
        <div style="max-width: 720px; width: 92%; line-height:1.4;">
          <h3>Welcome to RecallOS</h3>
          <p style="margin:8px 0 10px;">This app records your screen and microphone locally to make your history searchable. Nothing is uploaded. Ensure you comply with laws and policies applicable to you.</p>
          <div style="margin:8px 0 14px; padding:10px; border:1px solid var(--border); border-radius:8px; background: var(--muted);">
            <label style="display:flex; gap:8px; align-items:flex-start;">
              <input type="checkbox" id="fr-consent" />
              <span>I understand and consent to local recording on this device by RecallOS.</span>
            </label>
          </div>
          <ol style="padding-left: 18px;">
            <li style="margin-bottom:8px;">
              Data directory: <span id="fr-data-dir" style="font-family:monospace;">(default)</span>
              <div style="margin-top:6px;"><button id="fr-choose-dir">Choose Folder…</button></div>
            </li>
            <li style="margin-bottom:8px;">
              OCR Language: <select id="fr-ocr-lang"><option value="eng" selected>English (eng)</option><option value="spa">Spanish (spa)</option><option value="fra">French (fra)</option><option value="deu">German (deu)</option></select>
              <button id="fr-ensure-ocr">Ensure Language</button>
            </li>
            <li style="margin-bottom:8px;">
              STT Model: <select id="fr-stt-model"><option value="ggml-tiny.en.bin">tiny.en</option><option value="ggml-base.en.bin" selected>base.en</option><option value="ggml-small.en.bin">small.en</option><option value="ggml-medium.en.bin">medium.en</option></select>
              <button id="fr-ensure-stt">Ensure Model</button>
            </li>
            <li style="margin-bottom:8px;">
              Microphone: <select id="fr-mic"></select>
              <button id="fr-request-mic">Request Mic Permission</button>
            </li>
            <li style="margin-bottom:8px;">
              Encryption (SQLCipher):
              <div id="fr-enc-status" style="font-size:12px; color:#555; margin-top:4px;">Detecting…</div>
              <div id="fr-enc-setup" style="display:none; margin-top:6px;">
                <label for="fr-pass">Create passphrase:</label>
                <input type="password" id="fr-pass" placeholder="Enter passphrase" style="margin-left:6px;" />
                <button id="fr-pass-help" title="Show instructions">How to apply</button>
                <div id="fr-pass-instructions" style="display:none; margin-top:6px; font-size:12px; color:#444;">
                  <div>To enable encryption, restart the app with this environment variable set before launch (macOS zsh example):</div>
                  <pre style="background:#f7f7f7; padding:8px; border-radius:4px; white-space: pre; overflow:auto;">RECALLOS_PASSPHRASE=&lt;your-passphrase&gt; pnpm start</pre>
                  <div style="margin-top:6px;">Note: SQLCipher must be linked; if unavailable, the app will run with plain SQLite (WAL). Your passphrase is not stored by the app.</div>
                </div>
              </div>
            </li>
          </ol>
          <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:12px;">
            <button id="fr-cancel">Quit</button>
            <button id="fr-finish" disabled>Finish Setup</button>
          </div>
          <div id="fr-msg" style="margin-top:8px; color:#555; font-size:12px;"></div>
        </div>
      </div>
      <!-- Consent merged into First-Run -->
  <h1 class="muted" style="font-weight:600;">Quick Controls</h1>
      <p><small id="ping"></small></p>
      <hr />
      <section>
        <h3>Permissions</h3>
        <button id="mic-status">Mic Status</button>
        <button id="mic-request">Request Mic</button>
        <button id="screen-settings">Open Screen Recording Settings</button>
  <button id="screen-request">Request Screen Capture</button>
    <pre id="perm-out" style="white-space: pre-wrap"></pre>
  <div id="sys-audio" class="muted" style="margin-top:6px;"></div>
      </section>
      <hr />
  <!-- Preview section removed -->
      <hr />
      <section>
        <h3>Screen Recorder</h3>
        <div style="display:flex; gap:8px; align-items:center; flex-wrap: wrap;">
      <button id="rec-start" class="primary">Start Recording</button>
          <button id="rec-stop" disabled>Stop</button>
          <button id="rec-pause" disabled>Pause</button>
          <button id="rec-resume" disabled>Resume</button>
          <span id="rec-status"></span>
        </div>
  <div id="rec-previews" style="display:none; margin-top:8px; gap:8px; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));"></div>
        <div style="margin-top:8px; display:flex; gap:8px; align-items:center; flex-wrap: wrap;">
          <label for="cap-screen" style="margin-left:0;">Capture Screen</label>
          <input id="cap-screen" type="checkbox" checked />
          <label for="cap-mic" style="margin-left:8px;">Capture Mic</label>
          <input id="cap-mic" type="checkbox" checked />
          <label for="mic-select">Mic:</label>
          <select id="mic-select"></select>
          <label for="mic-role" style="margin-left:8px;">Tag as:</label>
          <select id="mic-role">
            <option value="me" selected>Me</option>
            <option value="others">Others (system/loopback)</option>
            <option value="unknown">Unknown</option>
          </select>
          <label for="ocr-lang" style="margin-left:12px;">OCR Lang:</label>
          <select id="ocr-lang">
            <option value="eng" selected>English (eng)</option>
            <option value="spa">Spanish (spa)</option>
            <option value="fra">French (fra)</option>
            <option value="deu">German (deu)</option>
          </select>
          <button id="ocr-lang-apply">Apply</button>
          <label for="stt-model" style="margin-left:12px;">STT Model:</label>
          <select id="stt-model">
            <option value="ggml-tiny.en.bin">tiny.en (fastest, lowest accuracy)</option>
            <option value="ggml-base.en.bin" selected>base.en (balanced)</option>
            <option value="ggml-small.en.bin">small.en (better, slower)</option>
            <option value="ggml-medium.en.bin">medium.en (best, slowest)</option>
          </select>
          <button id="stt-model-apply">Apply</button>
        </div>
      </section>
      <hr />
  <!-- Settings moved to Settings window. Use the Settings… button in the top bar. -->
      <hr />
      <section>
        <h3>Search</h3>
        <div style="display:flex; gap:8px; align-items:center; flex-wrap: wrap; margin-bottom:8px;">
          <input id="search-input" placeholder="Search… (supports phrases, AND/OR, prefix*)" style="flex:1; min-width:260px; padding:6px;" />
          <select id="search-type">
            <option value="">All types</option>
            <option value="ocr">OCR</option>
            <option value="transcript">Transcript</option>
          </select>
          <select id="search-speaker">
            <option value="">Any speaker</option>
            <option value="me">Me</option>
            <option value="others">Others</option>
            <option value="unknown">Unknown</option>
          </select>
          <input id="search-app" type="text" list="apps-list" placeholder="App bundle/exe (optional)" style="min-width:200px;" />
          <datalist id="apps-list"></datalist>
          <input id="search-window" type="text" placeholder="Window title contains…" style="min-width:220px;" />
          <input id="search-from" type="date" />
          <input id="search-to" type="date" />
          <button id="search-run">Search</button>
        </div>
  <div id="search-results" style="display:flex; flex-direction:column; gap:6px;"></div>
        <div style="display:flex; gap:8px; margin-top:6px;">
          <button id="search-prev">Prev</button>
          <button id="search-next">Next</button>
          <span id="search-page" style="align-self:center; color:#555;"></span>
        </div>
        <div style="display:flex; gap:8px; margin-top:8px; align-items:center; flex-wrap:wrap;">
          <button id="export-json">Export Results (JSON)</button>
          <button id="export-csv">Export Results (CSV)</button>
          <span class="muted">Exports the current page of results.</span>
        </div>
      </section>
      <hr />
  <!-- Per-app Defaults moved to Settings → Apps tab -->
    </div>
    <script>
      // Minimal smoke test
      const s = document.getElementById('ping');
      s.textContent = window.recallos?.ping?.() ?? 'no api';

      // Theme management
      const themeSelect = document.getElementById('theme-select');
      function applyTheme(mode) {
        const root = document.documentElement;
        if (!mode || mode === 'system') {
          root.removeAttribute('data-theme');
        } else if (mode === 'light' || mode === 'dark') {
          root.setAttribute('data-theme', mode);
        }
      }
      (async () => {
        try {
          const s = await window.recallos?.getSettings?.();
          const mode = (s && s.theme) ? s.theme : 'system';
          applyTheme(mode);
          if (themeSelect) themeSelect.value = mode;
        } catch {}
      })();
      themeSelect?.addEventListener('change', async () => {
        const val = themeSelect.value;
        applyTheme(val);
        try { await window.recallos?.setSetting?.('theme', val); } catch {}
      });

      // Settings window opener
      document.getElementById('open-settings')?.addEventListener('click', () => {
        try { window.recallos?.openSettings?.(); } catch {}
      });

      const permOut = document.getElementById('perm-out');
      document.getElementById('mic-status').addEventListener('click', async () => {
        const res = await window.recallos?.micPermissionStatus?.();
        permOut.textContent = JSON.stringify(res, null, 2);
      });
      document.getElementById('mic-request').addEventListener('click', async () => {
        const res = await window.recallos?.micPermissionRequest?.();
        permOut.textContent = JSON.stringify(res, null, 2);
      });
      document.getElementById('screen-settings').addEventListener('click', async () => {
        const res = await window.recallos?.openScreenRecordingSettings?.();
        permOut.textContent = JSON.stringify(res, null, 2);
      });
      document.getElementById('screen-request').addEventListener('click', async () => {
        try {
          let stream;
          if (navigator.mediaDevices && 'getDisplayMedia' in navigator.mediaDevices) {
            // Modern path
            stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
          } else {
            // Fallback for Electron contexts without getDisplayMedia: use desktop getUserMedia
            const sources = await window.recallos?.listCaptureSources?.(['screen']);
            if (!sources || sources.length === 0) throw new Error('No display sources available');
            const primary = sources.find(s => s.kind === 'screen') || sources[0];
            stream = await navigator.mediaDevices.getUserMedia({
              audio: false,
              video: {
                mandatory: {
                  chromeMediaSource: 'desktop',
                  chromeMediaSourceId: primary.id,
                  maxWidth: 2,
                  maxHeight: 2,
                  maxFrameRate: 1
                }
              }
            });
          }
          // Stop immediately; this is only to get macOS to register the app in Screen Recording
          stream.getTracks().forEach(t => t.stop());
          alert('Requested screen capture. If macOS asked you to grant Screen Recording, enable it in System Settings and fully quit and relaunch RecallOS.');
        } catch (e) {
          alert('Screen capture request failed: ' + (e?.message || e));
        }
      });
      (async () => {
        const det = await window.recallos?.detectSystemAudio?.();
        const el = document.getElementById('sys-audio');
        if (el && det) {
          el.textContent = det.detected ? `System audio device detected (${det.platform}).` : `No loopback device detected. ${det.hint || ''}`;
        }
      })();

  // Display Sources UI removed; single preview is kept for quick checks

    // --- Recording to chunks (multi-display) ---
  let recordingStream = null; // preview-only stream
  let multiRecorders = [];
  let micShared = null;
  let isPaused = false;
  let isStarting = false;
      const recStatus = document.getElementById('rec-status');
      const micSelect = document.getElementById('mic-select');
      const capScreenEl = document.getElementById('cap-screen');
      const capMicEl = document.getElementById('cap-mic');
      let privacyEnabled = true;
      let micDevicePref = '';

      async function populateMics() {
        const devs = await window.recallos?.listAudioDevices?.();
        micSelect.innerHTML = '';
        (devs || []).forEach(d => {
          const opt = document.createElement('option');
          opt.value = d.deviceId;
          opt.textContent = d.label || d.deviceId;
          micSelect.appendChild(opt);
        });
      }

      async function ensureScreenStream() {
        if (recordingStream) return recordingStream;
        // Try getDisplayMedia first, fall back to desktop getUserMedia
        try {
          if (navigator.mediaDevices && 'getDisplayMedia' in navigator.mediaDevices) {
            const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
            const video = document.getElementById('preview');
            if (video) { (video).srcObject = stream; try { await (video).play(); } catch {} }
            recordingStream = stream;
            return stream;
          }
        } catch (e) {
          console.warn('getDisplayMedia failed:', e);
        }
        try {
          const sources = await window.recallos?.listCaptureSources?.(['screen']);
          if (!sources || sources.length === 0) throw new Error('No display sources');
          const primary = sources.find(s => s.kind === 'screen') || sources[0];
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: false,
            video: { mandatory: { chromeMediaSource: 'desktop', chromeMediaSourceId: primary.id, maxFrameRate: 30 } }
          });
          const video = document.getElementById('preview');
          if (video) { (video).srcObject = stream; try { await (video).play(); } catch {} }
          recordingStream = stream;
          return stream;
        } catch (e) {
          throw e;
        }
      }

      async function startRecording() {
        try { await window.recallos?.log?.('info', 'startRecording: invoked'); } catch {}
        const wantScreen = !!capScreenEl?.checked;
        const wantMic = !!capMicEl?.checked;
        try { await window.recallos?.log?.('info', 'startRecording: toggles', { wantScreen, wantMic }); } catch {}
        try {
          const mrAvail = typeof MediaRecorder !== 'undefined';
          const mimeCandidates = [
            'video/webm;codecs=vp9,opus',
            'video/webm;codecs=vp8,opus',
            'video/webm',
            'audio/webm;codecs=opus',
            'audio/webm'
          ];
          const mimeSupport = mrAvail ? mimeCandidates.map(m => ({ mime: m, supported: MediaRecorder.isTypeSupported(m) })) : [];
          const constraintsSupport = (navigator.mediaDevices && navigator.mediaDevices.getSupportedConstraints) ? navigator.mediaDevices.getSupportedConstraints() : {};
          const gdmAvail = !!(navigator.mediaDevices && 'getDisplayMedia' in navigator.mediaDevices);
          await window.recallos?.log?.('info', 'capabilities', { mediaRecorder: mrAvail, mimeSupport, constraintsSupport, getDisplayMedia: gdmAvail });
        } catch {}
        try {
          const devs = await navigator.mediaDevices.enumerateDevices();
          const info = (devs||[]).map(d => ({ kind: d.kind, label: d.label, deviceId: d.deviceId }));
          await window.recallos?.log?.('info', 'enumerateDevices', info);
        } catch (e) { try { await window.recallos?.log?.('warn', 'enumerateDevices failed', { err: String(e) }); } catch {} }
        if (!wantScreen && !wantMic) { try { await window.recallos?.log?.('warn', 'startRecording: neither screen nor mic selected'); } catch {} alert('Both screen and mic capture are disabled. Enable at least one.'); return false; }
        // Prepare mic (once) if requested
        micShared = null;
    if (wantMic) {
          try {
            const sel = (micSelect && micSelect.value) ? micSelect.value : (micDevicePref || '');
      const audioConstraint = sel ? { deviceId: { exact: sel } } : true;
      micShared = await navigator.mediaDevices.getUserMedia({ audio: audioConstraint, video: false });
            try {
              const aTracks = micShared.getAudioTracks();
              await window.recallos?.log?.('info', 'startRecording: mic stream acquired', {
                deviceId: sel || 'default',
                tracks: aTracks.length,
                settings: aTracks[0] ? aTracks[0].getSettings?.() : null
              });
            } catch {}
          } catch {}
        }

        // Build one recorder per display, or a single audio-only recorder when screen is off
        multiRecorders = [];
        const opts = { mimeType: 'video/webm;codecs=vp9,opus' };
        const roleSel = document.getElementById('mic-role');
        const audio_role = roleSel ? roleSel.value : 'unknown';

        let startedAny = false;
        // Reset and show multi-preview grid when we intend to capture screens
        const recPreviews = document.getElementById('rec-previews');
        if (wantScreen && recPreviews) {
          recPreviews.innerHTML = '';
          recPreviews.style.display = 'grid';
        }
        if (wantScreen) {
          let sources = [];
          try {
            sources = await window.recallos?.listCaptureSources?.(['screen']) || [];
            try { await window.recallos?.log?.('info', 'startRecording: sources', { count: sources.length, items: sources }); } catch {}
          } catch (e) {
            try { await window.recallos?.log?.('error', 'listCaptureSources failed', { err: String(e) }); } catch {}
          }
          if (!sources || sources.length === 0) {
            try { await window.recallos?.log?.('warn', 'startRecording: no screen sources'); } catch {}
          }
          for (const src of sources.filter(s => s.kind === 'screen')) {
            try {
              const vConstraints = { mandatory: { chromeMediaSource: 'desktop', chromeMediaSourceId: src.id, maxFrameRate: 30 } };
              try { await window.recallos?.log?.('info', 'screen getUserMedia: attempt', { source: src, constraints: vConstraints }); } catch {}
              const screenStream = await navigator.mediaDevices.getUserMedia({
                audio: false,
                video: vConstraints
              });
              try {
                const vTracks = screenStream.getVideoTracks();
                await window.recallos?.log?.('info', 'screen stream acquired', {
                  tracks: vTracks.length,
                  settings: vTracks[0] ? vTracks[0].getSettings?.() : null
                });
              } catch {}
              const mixed = new MediaStream();
              screenStream.getVideoTracks().forEach(t => mixed.addTrack(t));
              if (micShared) {
                micShared.getAudioTracks().forEach(t => mixed.addTrack(t.clone ? t.clone() : t));
              }
              let rec = null;
              try {
                rec = new MediaRecorder(mixed, opts);
                try { await window.recallos?.log?.('info', 'MediaRecorder created', { mime: opts.mimeType, actual: rec.mimeType }); } catch {}
              } catch (err1) {
                try { await window.recallos?.log?.('warn', 'MediaRecorder fell back (no opts)', { err: String(err1) }); } catch {}
                try {
                  rec = new MediaRecorder(mixed);
                  try { await window.recallos?.log?.('info', 'MediaRecorder created (no opts)', { actual: rec.mimeType }); } catch {}
                } catch (err2) {
                  try { await window.recallos?.log?.('error', 'MediaRecorder creation failed', { err: String(err2) }); } catch {}
                }
              }
              const state = { rec, stream: mixed, displayId: src.displayId || src.id || null, displayName: src.name || 'Screen', lastChunkStart: Date.now() };
              rec.ondataavailable = async (e) => {
                try {
                  if (!e.data || e.data.size === 0) return;
                  const arrayBuf = await e.data.arrayBuffer();
                  const startedAt = state.lastChunkStart;
                  const durationMs = Date.now() - state.lastChunkStart;
                  state.lastChunkStart = Date.now();
                  await window.recallos?.saveChunk?.(arrayBuf, { startedAt, durationMs, type: 'video', codec: 'webm', ext: 'webm', audio_role, display_id: String(state.displayId || ''), display_name: state.displayName });
                } catch (err) {
          console.error('saveChunk failed', err);
          try { await window.recallos?.log?.('error', 'saveChunk failed', { err: String(err) }); } catch {}
                }
              };
              rec.onstart = async () => { recStatus.textContent = 'Recording...'; if (privacyEnabled) document.getElementById('rec-badge').style.display='inline-block'; await window.recallos?.setRecordingIndicator?.(true); };
              rec.onstop = async () => { recStatus.textContent = 'Stopped.'; document.getElementById('rec-badge').style.display='none'; await window.recallos?.setRecordingIndicator?.(false); };
              rec.onpause = () => { isPaused = true; recStatus.textContent = 'Paused'; };
              rec.onresume = () => { isPaused = false; recStatus.textContent = 'Recording...'; };
              rec.onerror = async (evt) => { try { await window.recallos?.log?.('error', 'recorder error', { message: evt?.error?.message || String(evt) }); } catch {} };
              try { await window.recallos?.log?.('info', 'recorder: about to start', { name: state.displayName }); } catch {}
              rec.start(5000);
              multiRecorders.push(state);
        try { await window.recallos?.log?.('info', 'recorder started', { displayId: state.displayId, name: state.displayName }); } catch {}
        // Create a preview tile for this display
        try {
                  const grid = document.getElementById('rec-previews');
                  if (grid) {
                    const tile = document.createElement('div');
                    tile.className = 'card';
                    tile.style.display = 'flex';
                    tile.style.flexDirection = 'column';
                    tile.style.gap = '6px';
                    const label = document.createElement('div');
                    label.textContent = state.displayName || 'Display';
                    label.style.fontSize = '12px';
                    label.style.color = 'var(--muted-foreground)';
                    const vid = document.createElement('video');
                    vid.autoplay = true; vid.muted = true; vid.playsInline = true; vid.controls = false;
                    vid.style.width = '100%'; vid.style.background = '#000'; vid.style.borderRadius = '6px'; vid.style.objectFit = 'contain';
                    vid.srcObject = screenStream;
                    tile.appendChild(vid);
                    tile.appendChild(label);
                    grid.appendChild(tile);
                  }
                  // Keep legacy single preview bound to the first stream if empty
                  const single = document.getElementById('preview');
                  if (single && !single.srcObject) { single.srcObject = screenStream; await single.play?.(); }
                } catch {}
              startedAny = true;
            } catch (e) {
              console.error('Failed to start recorder for source', src, e);
        try { await window.recallos?.log?.('warn', 'recorder start failed', { source: src?.id, err: String(e) }); } catch {}
            }
          }
        } else if (wantMic && !wantScreen) {
          try {
            const mixed = new MediaStream();
            if (!micShared) micShared = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            micShared.getAudioTracks().forEach(t => mixed.addTrack(t));
            let rec = null;
            try { rec = new MediaRecorder(mixed, { mimeType: 'audio/webm;codecs=opus' }); } catch { try { rec = new MediaRecorder(mixed); } catch {} }
            const state = { rec, stream: mixed, displayId: null, displayName: 'Audio Only', lastChunkStart: Date.now() };
            rec.ondataavailable = async (e) => {
              try {
                if (!e.data || e.data.size === 0) return;
                const arrayBuf = await e.data.arrayBuffer();
                const startedAt = state.lastChunkStart;
                const durationMs = Date.now() - state.lastChunkStart;
                state.lastChunkStart = Date.now();
                await window.recallos?.saveChunk?.(arrayBuf, { startedAt, durationMs, type: 'audio', codec: 'webm', ext: 'webm', audio_role, display_id: null, display_name: null });
              } catch (err) { console.error('saveChunk failed', err); }
            };
            rec.onstart = async () => { recStatus.textContent = 'Recording...'; if (privacyEnabled) document.getElementById('rec-badge').style.display='inline-block'; await window.recallos?.setRecordingIndicator?.(true); };
            rec.onstop = async () => { recStatus.textContent = 'Stopped.'; document.getElementById('rec-badge').style.display='none'; await window.recallos?.setRecordingIndicator?.(false); };
            rec.onpause = () => { isPaused = true; recStatus.textContent = 'Paused'; };
            rec.onresume = () => { isPaused = false; recStatus.textContent = 'Recording...'; };
            rec.onerror = async (evt) => { try { await window.recallos?.log?.('error', 'audio-only recorder error', { message: evt?.error?.message || String(evt) }); } catch {} };
            try { await window.recallos?.log?.('info', 'audio-only: about to start'); } catch {}
            rec.start(5000);
            multiRecorders.push(state);
            try { await window.recallos?.log?.('info', 'audio-only recorder started'); } catch {}
            startedAny = true;
          } catch (e) {
            alert('Could not start microphone recording.');
            try { await window.recallos?.log?.('error', 'mic-only recorder failed', { err: String(e) }); } catch {}
            return false;
          }
        }
  // Fallback: user picker via getDisplayMedia if per-screen capture failed or no sources
  if (!startedAny && wantScreen) {
          try {
            try { await window.recallos?.log?.('info', 'fallback: calling getDisplayMedia'); } catch {}
            const displayStream = await navigator.mediaDevices.getDisplayMedia({ video: { frameRate: 30 }, audio: false });
            try {
              const vTracks = displayStream.getVideoTracks();
              await window.recallos?.log?.('info', 'fallback stream acquired', { tracks: vTracks.length, settings: vTracks[0] ? vTracks[0].getSettings?.() : null });
            } catch {}
            const mixed = new MediaStream();
            displayStream.getVideoTracks().forEach(t => mixed.addTrack(t));
            if (micShared) { micShared.getAudioTracks().forEach(t => mixed.addTrack(t.clone ? t.clone() : t)); }
            let rec = null;
            try {
              rec = new MediaRecorder(mixed, opts);
              try { await window.recallos?.log?.('info', 'fallback MediaRecorder created', { mime: opts.mimeType, actual: rec.mimeType }); } catch {}
            } catch (err1) {
              try { await window.recallos?.log?.('warn', 'fallback MediaRecorder fell back (no opts)', { err: String(err1) }); } catch {}
              try {
                rec = new MediaRecorder(mixed);
                try { await window.recallos?.log?.('info', 'fallback MediaRecorder created (no opts)', { actual: rec.mimeType }); } catch {}
              } catch (err2) {
                try { await window.recallos?.log?.('error', 'fallback MediaRecorder creation failed', { err: String(err2) }); } catch {}
              }
            }
            const state = { rec, stream: mixed, displayId: null, displayName: 'Display (picker)', lastChunkStart: Date.now() };
            rec.ondataavailable = async (e) => {
              try {
                if (!e.data || e.data.size === 0) return;
                const arrayBuf = await e.data.arrayBuffer();
                const startedAt = state.lastChunkStart;
                const durationMs = Date.now() - state.lastChunkStart;
                state.lastChunkStart = Date.now();
                await window.recallos?.saveChunk?.(arrayBuf, { startedAt, durationMs, type: 'video', codec: 'webm', ext: 'webm', audio_role, display_id: null, display_name: state.displayName });
              } catch (err) { console.error('saveChunk failed', err); }
            };
            rec.onstart = async () => { recStatus.textContent = 'Recording...'; if (privacyEnabled) document.getElementById('rec-badge').style.display='inline-block'; await window.recallos?.setRecordingIndicator?.(true); };
            rec.onstop = async () => { recStatus.textContent = 'Stopped.'; document.getElementById('rec-badge').style.display='none'; await window.recallos?.setRecordingIndicator?.(false); };
            rec.onpause = () => { isPaused = true; recStatus.textContent = 'Paused'; };
            rec.onresume = () => { isPaused = false; recStatus.textContent = 'Recording...'; };
            rec.start(5000);
            multiRecorders.push(state);
            startedAny = true;
            // Show fallback display in preview grid and single preview
            try {
              const grid = document.getElementById('rec-previews');
              if (grid) {
                const tile = document.createElement('div');
                tile.className = 'card';
                tile.style.display = 'flex';
                tile.style.flexDirection = 'column';
                tile.style.gap = '6px';
                const label = document.createElement('div');
                label.textContent = 'Display (picker)';
                label.style.fontSize = '12px';
                label.style.color = 'var(--muted-foreground)';
                const vid = document.createElement('video');
                vid.autoplay = true; vid.muted = true; vid.playsInline = true; vid.controls = false;
                vid.style.width = '100%'; vid.style.background = '#000'; vid.style.borderRadius = '6px'; vid.style.objectFit = 'contain';
                vid.srcObject = displayStream;
                tile.appendChild(vid);
                tile.appendChild(label);
                grid.appendChild(tile);
                grid.style.display = 'grid';
              }
              const video = document.getElementById('preview'); if (video) { video.srcObject = displayStream; await video.play?.(); }
            } catch {}
          } catch (e) {
            console.error('getDisplayMedia fallback failed', e);
            alert('Screen picker was canceled or blocked. Please allow screen capture and try again.');
            try { await window.recallos?.log?.('error', 'getDisplayMedia fallback failed', { err: String(e) }); } catch {}
            return false;
          }
        }
        if (!startedAny) { try { await window.recallos?.log?.('error', 'startRecording: no recorders started'); } catch {}; return false; }
        try { await window.recallos?.log?.('info', 'startRecording: success', { count: multiRecorders.length }); } catch {}
        return true;
      }

      function stopRecording() {
        try { multiRecorders.forEach(r => { try { if (r.rec && r.rec.state !== 'inactive') r.rec.stop(); } catch {} }); } catch {}
        multiRecorders = [];
        try { if (micShared) { micShared.getTracks().forEach(t => t.stop()); } } catch {}
        micShared = null;
      }

      document.getElementById('rec-start').addEventListener('click', async () => {
        if (isStarting) return;
        isStarting = true;
        const ok = await startRecording();
        isStarting = false;
        if (!ok) return;
        (document.getElementById('rec-start')).disabled = true;
        (document.getElementById('rec-stop')).disabled = false;
        (document.getElementById('rec-pause')).disabled = false;
        (document.getElementById('rec-resume')).disabled = true;
      });
      document.getElementById('rec-stop').addEventListener('click', () => {
        stopRecording();
        (document.getElementById('rec-start')).disabled = false;
        (document.getElementById('rec-stop')).disabled = true;
        (document.getElementById('rec-pause')).disabled = true;
        (document.getElementById('rec-resume')).disabled = true;
        isPaused = false;
  try { const grid = document.getElementById('rec-previews'); if (grid) { grid.innerHTML = ''; grid.style.display = 'none'; } } catch {}
      });
      document.getElementById('rec-pause').addEventListener('click', async () => {
        try { multiRecorders.forEach(r => { try { if (r.rec && r.rec.state === 'recording') r.rec.pause(); } catch {} }); } catch {}
        (document.getElementById('rec-pause')).disabled = true;
        (document.getElementById('rec-resume')).disabled = false;
        try { await window.recallos?.log?.('info', 'paused'); } catch {}
      });
      document.getElementById('rec-resume').addEventListener('click', async () => {
        try { multiRecorders.forEach(r => { try { if (r.rec && r.rec.state === 'paused') r.rec.resume(); } catch {} }); } catch {}
        (document.getElementById('rec-pause')).disabled = false;
        (document.getElementById('rec-resume')).disabled = true;
        try { await window.recallos?.log?.('info', 'resumed'); } catch {}
      });

  // Settings actions moved to Settings window

      // Bind the preview stream to be used for recording too
  (async () => {
        // Unified first-run + consent handling
        const settings = await window.recallos?.getSettings?.();
        const needsFirstRun = !settings || !settings.first_run_completed;
        const needsConsent = !settings || settings.consent_ack !== '1';
        const frEl = document.getElementById('first-run');
        if ((needsFirstRun || needsConsent) && frEl) {
          frEl.style.display = 'flex';
          const dirSpan = document.getElementById('fr-data-dir');
          const setMsg = (m) => { const el = document.getElementById('fr-msg'); if (el) el.textContent = m; };
          if (settings?.data_dir) dirSpan.textContent = settings.data_dir;
          const consentCb = document.getElementById('fr-consent');
          const finishBtn = document.getElementById('fr-finish');
          const updateFinish = () => { finishBtn.disabled = !(consentCb && consentCb.checked); };
          consentCb?.addEventListener('change', updateFinish);
          updateFinish();
          document.getElementById('fr-choose-dir').addEventListener('click', async () => {
            const res = await window.recallos?.chooseDirectory?.();
            if (res?.ok && res.path) {
              dirSpan.textContent = res.path;
              await window.recallos?.setSetting?.('data_dir', res.path);
            }
          });
          // Populate mics
          const micSel = document.getElementById('fr-mic');
          const devs = await window.recallos?.listAudioDevices?.();
          (devs||[]).forEach(d => { const o=document.createElement('option'); o.value=d.deviceId; o.textContent=d.label||d.deviceId; micSel.appendChild(o); });
          document.getElementById('fr-request-mic').addEventListener('click', async () => {
            const r = await window.recallos?.micPermissionRequest?.();
            setMsg(r?.granted ? 'Microphone access granted.' : 'Microphone access not granted.');
          });
          document.getElementById('fr-ensure-ocr').addEventListener('click', async () => {
            const lang = (document.getElementById('fr-ocr-lang')).value;
            const r = await window.recallos?.ensureOcrLanguage?.(lang);
            setMsg(r?.ok ? `OCR language ensured: ${lang}` : `OCR failed: ${r?.error||'unknown'}`);
          });
          document.getElementById('fr-ensure-stt').addEventListener('click', async () => {
            const model = (document.getElementById('fr-stt-model')).value;
            const r = await window.recallos?.setSttModel?.(model);
            setMsg(r?.ok ? `STT model ready: ${model}` : `Model failed: ${r?.error||'unknown'}`);
          });
          document.getElementById('fr-cancel').addEventListener('click', () => window.close());
          document.getElementById('fr-finish').addEventListener('click', async () => {
            // Require consent, then mark first-run complete
            try { await window.recallos?.setSetting?.('consent_ack', (document.getElementById('fr-consent')).checked ? '1' : '0'); } catch {}
            try { await window.recallos?.setSetting?.('first_run_completed', '1'); } catch {}
            frEl.style.display = 'none';
          });
          // SQL features + encryption guidance
          try {
            const feats = await window.recallos?.getSqlFeatures?.();
            const enc = document.getElementById('fr-enc-status');
            const setup = document.getElementById('fr-enc-setup');
            if (feats && feats.ok) {
              if (feats.sqlcipher) {
                enc.textContent = `SQLCipher linked (cipher=${feats.cipherVersion || 'unknown'}). You can enable encryption by restarting with RECALLOS_PASSPHRASE.`;
                setup.style.display = 'block';
              } else {
                enc.textContent = 'SQLCipher is not linked. The app will use plain SQLite (WAL). To use encryption, rebuild with SQLCipher-enabled SQLite.';
                setup.style.display = 'none';
              }
            } else {
              enc.textContent = 'Could not detect SQL features.';
            }
          } catch {}
          document.getElementById('fr-pass-help').addEventListener('click', () => {
            const inst = document.getElementById('fr-pass-instructions');
            inst.style.display = inst.style.display === 'none' ? 'block' : 'none';
          });
        }
        const prevBtnHandler = async (src) => {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({
              audio: false,
              video: {
                mandatory: {
                  chromeMediaSource: 'desktop',
                  chromeMediaSourceId: src.id,
                  maxFrameRate: 30
                }
              }
            });
            const video = document.getElementById('preview');
            if (video) {
              (video).srcObject = stream;
              await (video).play();
            }
            recordingStream = stream;
          } catch (e) {
            alert('Failed to start preview: ' + (e?.message || e));
          }
        };
        // Rewire the Preview buttons with shared handler
        const cont = document.getElementById('sources');
        const observer = new MutationObserver(() => {
          cont.querySelectorAll('button').forEach((btn) => {
            if ((btn)._recBound) return;
            (btn)._recBound = true;
            btn.addEventListener('click', async (ev) => {
              const card = btn.parentElement;
              const name = card.querySelector('div')?.textContent || '';
              const data = await window.recallos?.listCaptureSources?.(['screen','window']);
              const match = (data||[]).find(s => s.name === name);
              if (match) await prevBtnHandler(match);
            });
          });
        });
        observer.observe(cont, { childList: true, subtree: true });
  await populateMics();
  // Apply initial settings and wire events
  try {
    const s = await window.recallos?.getSettings?.();
    // Capture toggles
    try { capScreenEl.checked = String(s?.capture_screen || 'on') !== 'off'; capMicEl.checked = String(s?.capture_mic || 'on') !== 'off'; } catch {}
    // Mic pref
    micDevicePref = s?.mic_device_id || '';
    const opt = Array.from(micSelect.options).find(o => o.value === micDevicePref); if (opt) micSelect.value = micDevicePref;
  } catch {}

  // Settings-related handlers moved to Settings window
  micSelect?.addEventListener('change', async () => { micDevicePref = micSelect.value; try { await window.recallos?.setSetting?.('mic_device_id', micDevicePref); } catch {} });
      })();

      // --- Search wiring ---
      let searchOffset = 0;
      const searchLimit = 20;
      async function runSearch(reset = false) {
        try {
          const q = (document.getElementById('search-input')).value.trim();
          if (!q) return;
          if (reset) searchOffset = 0;
          const type = (document.getElementById('search-type')).value || undefined;
          const speaker = (document.getElementById('search-speaker')).value || undefined;
          const app = (document.getElementById('search-app')).value.trim() || undefined;
          const windowTitle = (document.getElementById('search-window')).value.trim() || undefined;
          const fromStr = (document.getElementById('search-from')).value;
          const toStr = (document.getElementById('search-to')).value;
          const toEpoch = (dstr) => dstr ? Math.floor(new Date(dstr + 'T00:00:00').getTime() / 1000) : undefined;
          const from = toEpoch(fromStr);
          const to = toEpoch(toStr) ? (toEpoch(toStr) + 24*3600 - 1) : undefined;
          const opts = { type, speaker, from, to, app, window: windowTitle };
          const rows = await window.recallos?.searchSnippets?.(q, searchLimit, searchOffset, 80, opts);
          const cont = document.getElementById('search-results');
          cont.innerHTML = '';
          (rows||[]).forEach(r => {
            const item = document.createElement('div');
            item.style.border = '1px solid #ddd'; item.style.padding = '6px'; item.style.borderRadius = '4px';
            item.dataset.row = JSON.stringify(r);
            const meta = document.createElement('div'); meta.style.fontSize = '12px'; meta.style.color = '#555';
            const appText = (r.app_name || r.app_bundle) ? ` • ${r.app_name || r.app_bundle}${r.window_title ? ` — “${String(r.window_title).slice(0,60)}”` : ''}` : '';
            meta.textContent = `${r.type} • t=${Math.floor(r.ts_ms/1000)}s${appText}`;
            const snip = document.createElement('div'); snip.innerHTML = r.snippet.replaceAll('<','&lt;').replaceAll('>','&gt;');
            const actions = document.createElement('div'); actions.style.marginTop = '4px';
            const btn = document.createElement('button'); btn.textContent = 'Jump';
            btn.addEventListener('click', async () => {
              const m = await window.recallos?.getMoment?.({ chunk_id: r.chunk_id, ts_ms: r.ts_ms });
              if (m && m.ok) {
                const video = document.getElementById('preview');
                const url = m.path.startsWith('file://') ? m.path : `file://${m.path}`;
                video.src = url; // play local file with file:// scheme
                try { await video.play(); } catch {}
                // Seek when metadata is loaded
                video.onloadedmetadata = () => { video.currentTime = m.absMs / 1000; };
              } else {
                alert('Failed to open media.');
              }
            });
            actions.appendChild(btn);
            item.appendChild(meta);
            item.appendChild(snip);
            item.appendChild(actions);
            cont.appendChild(item);
          });
          document.getElementById('search-page').textContent = `Showing ${searchOffset+1}-${searchOffset+(rows?.length||0)}`;
        } catch (e) {
          console.error('search failed', e);
        }
      }
      document.getElementById('search-run').addEventListener('click', () => runSearch(true));
      document.getElementById('search-next').addEventListener('click', () => { searchOffset += searchLimit; runSearch(); });
      document.getElementById('search-prev').addEventListener('click', () => { searchOffset = Math.max(0, searchOffset - searchLimit); runSearch(); });
      async function exportResults(format) {
        try {
          // Collect current rendered rows to avoid re-query differences
          const rows = Array.from(document.querySelectorAll('#search-results > div')).map(div => {
            try { return JSON.parse(div.dataset.row || 'null'); } catch { return null; }
          }).filter(Boolean);
          if (!rows.length) { alert('No results on this page to export.'); return; }
          const dir = await window.recallos?.chooseDirectory?.();
          if (!dir?.ok || !dir.path) return;
          const filename = `recallos-search-${Date.now()}.${format}`;
          const outPath = `${dir.path}/${filename}`;
          const res = await window.recallos?.exportResults?.(rows, outPath, format);
          if (res?.ok) alert(`Exported ${res.count} row(s) to ${res.path}`); else alert(`Export failed: ${res?.error||'unknown'}`);
        } catch (e) { alert('Export failed.'); }
      }
      document.getElementById('export-json').addEventListener('click', () => exportResults('json'));
      document.getElementById('export-csv').addEventListener('click', () => exportResults('csv'));

      // Populate app suggestions for search filter
      (async () => {
        try {
          const res = await window.recallos?.listApps?.();
          if (res?.ok && Array.isArray(res.apps)) {
            const dl = document.getElementById('apps-list');
            dl.innerHTML = '';
            res.apps.forEach(a => {
              const opt = document.createElement('option');
              opt.value = a.bundle_or_exe;
              opt.label = a.display_name || a.bundle_or_exe;
              dl.appendChild(opt);
            });
          }
        } catch {}
      })();

  // Per-app Defaults moved to Settings window
    </script>
  </body>
</html>
